@:jsRequire("socket.io-client") @valueModuleOnly extern class SocketIoClient {
	/**
		Protocol version.
	**/
	static final protocol : Float;
	/**
		Looks up an existing `Manager` for multiplexing.
		If the user summons:
		
		   `io('http://localhost/a');`
		   `io('http://localhost/b');`
		
		We reuse the existing instance based on same scheme/port/host,
		and we initialize sockets for each namespace.
	**/
	@:overload(function(uri:String, ?opts:{ /** Should we force a new Manager for this connection? **/ @:optional var forceNew : Bool; /** Should we multiplex our connection (reuse existing Manager) ? **/ @:optional var multiplex : Bool; /** The path to get our client file from, in the case of the serverserving it **/ @:optional var path : String; /** Should we allow reconnections? **/ @:optional var reconnection : Bool; /** How many reconnection attempts should we try? **/ @:optional var reconnectionAttempts : Float; /** The time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelay : Float; /** The max time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelayMax : Float; /** Used in the exponential backoff jitter when reconnecting **/ @:optional var randomizationFactor : Float; /** The timeout in milliseconds for our connection attempt **/ @:optional var timeout : Float; /** Should we automatically connect? **/ @:optional var autoConnect : Bool; /** the parser to use. Defaults to an instance of the Parser that ships with socket.io. **/ @:optional var parser : Dynamic; /** The host that we're connecting to. Set from the URI passed when connecting **/ @:optional var host : String; /** The hostname for our connection. Set from the URI passed when connecting **/ @:optional var hostname : String; /** If this is a secure connection. Set from the URI passed when connecting **/ @:optional var secure : Bool; /** The port for our connection. Set from the URI passed when connecting **/ @:optional var port : ts.AnyOf2<String, Float>; /** Any query parameters in our uri. Set from the URI passed when connecting **/ @:optional var query : haxe.DynamicAccess<Dynamic>; /** `http.Agent` to use, defaults to `false` (NodeJS only) **/ @:optional var agent : ts.AnyOf2<String, Bool>; /** Whether the client should try to upgrade the transport fromlong-polling to something better. **/ @:optional var upgrade : Bool; /** Forces base 64 encoding for polling transport even when XHR2responseType is available and WebSocket even if the used standardsupports binary. **/ @:optional var forceBase64 : Bool; /** The param name to use as our timestamp key **/ @:optional var timestampParam : String; /** Whether to add the timestamp with each transport request. Note: thisis ignored if the browser is IE or Android, in which case requestsare always stamped **/ @:optional var timestampRequests : Bool; /** A list of transports to try (in order). Engine.io always attempts toconnect directly with the first one, provided the feature detection testfor it passes. **/ @:optional var transports : Array<String>; /** The port the policy server listens on **/ @:optional var policyPost : Float; /** If true and if the previous websocket connection to the server succeeded,the connection attempt will bypass the normal upgrade process and willinitially try websocket. A connection attempt following a transport errorwill use the normal upgrade process. It is recommended you turn this ononly when using SSL/TLS connections, or if you know that your network doesnot block websockets. **/ @:optional var rememberUpgrade : Bool; /** Are we only interested in transports that support binary? **/ @:optional var onlyBinaryUpgrades : Bool; /** Timeout for xhr-polling requests in milliseconds (0) (only for polling transport) **/ @:optional var requestTimeout : Float; /** Transport options for Node.js client (headers etc) **/ @:optional var transportOptions : Dynamic; /** (SSL) Certificate, Private key and CA certificates to use for SSL.Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var pfx : String; /** (SSL) Private key to use for SSL. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var key : String; /** (SSL) A string or passphrase for the private key or pfx. Can beused in Node.js client environment to manually specify certificateinformation. **/ @:optional var passphrase : String; /** (SSL) Public x509 certificate to use. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var cert : String; /** (SSL) An authority certificate or array of authority certificates tocheck the remote host against.. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var ca : ts.AnyOf2<String, Array<String>>; /** (SSL) A string describing the ciphers to use or exclude. Consult the[cipher format list](http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT) fordetails on the format.. Can be used in Node.js client environment tomanually specify certificate information. **/ @:optional var ciphers : String; /** (SSL) If true, the server certificate is verified against the list ofsupplied CAs. An 'error' event is emitted if verification fails.Verification happens at the connection level, before the HTTP requestis sent. Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var rejectUnauthorized : Bool; /** Headers that will be passed for each request to the server (via xhr-polling and via websockets).These values then can be used during handshake or for special proxies. **/ @:optional var extraHeaders : haxe.DynamicAccess<String>; /** Whether to include credentials (cookies, authorization headers, TLSclient certificates, etc.) with cross-origin XHR polling requests **/ @:optional var withCredentials : Bool; /** Whether to automatically close the connection whenever the beforeunload event is received. **/ @:optional var closeOnBeforeunload : Bool; /** Whether to always use the native timeouts. This allows the client toreconnect when the native timeout functions are overridden, such as whenmock clocks are installed. **/ @:optional var useNativeTimers : Bool; /** weather we should unref the reconnect timer when it iscreate automatically **/ @:optional var autoUnref : Bool; /** parameters of the WebSocket permessage-deflate extension (see ws module api docs). Set to false to disable. **/ @:optional var perMessageDeflate : { var threshold : Float; }; /** Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols,so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server tobe able to handle different types of interactions depending on the specified protocol) **/ @:optional var protocols : ts.AnyOf2<String, Array<String>>; /** the authentication payload sent when connecting to the Namespace **/ @:optional var auth : ts.AnyOf2<haxe.DynamicAccess<Dynamic>, (cb:(data:Dynamic) -> Void) -> Void>; }):socket_io_client.Socket<socket_io.component_emitter.DefaultEventsMap, socket_io.component_emitter.DefaultEventsMap> { })
	@:overload(function(uri:ts.AnyOf2<String, { /** Should we force a new Manager for this connection? **/ @:optional var forceNew : Bool; /** Should we multiplex our connection (reuse existing Manager) ? **/ @:optional var multiplex : Bool; /** The path to get our client file from, in the case of the serverserving it **/ @:optional var path : String; /** Should we allow reconnections? **/ @:optional var reconnection : Bool; /** How many reconnection attempts should we try? **/ @:optional var reconnectionAttempts : Float; /** The time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelay : Float; /** The max time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelayMax : Float; /** Used in the exponential backoff jitter when reconnecting **/ @:optional var randomizationFactor : Float; /** The timeout in milliseconds for our connection attempt **/ @:optional var timeout : Float; /** Should we automatically connect? **/ @:optional var autoConnect : Bool; /** the parser to use. Defaults to an instance of the Parser that ships with socket.io. **/ @:optional var parser : Dynamic; /** The host that we're connecting to. Set from the URI passed when connecting **/ @:optional var host : String; /** The hostname for our connection. Set from the URI passed when connecting **/ @:optional var hostname : String; /** If this is a secure connection. Set from the URI passed when connecting **/ @:optional var secure : Bool; /** The port for our connection. Set from the URI passed when connecting **/ @:optional var port : ts.AnyOf2<String, Float>; /** Any query parameters in our uri. Set from the URI passed when connecting **/ @:optional var query : haxe.DynamicAccess<Dynamic>; /** `http.Agent` to use, defaults to `false` (NodeJS only) **/ @:optional var agent : ts.AnyOf2<String, Bool>; /** Whether the client should try to upgrade the transport fromlong-polling to something better. **/ @:optional var upgrade : Bool; /** Forces base 64 encoding for polling transport even when XHR2responseType is available and WebSocket even if the used standardsupports binary. **/ @:optional var forceBase64 : Bool; /** The param name to use as our timestamp key **/ @:optional var timestampParam : String; /** Whether to add the timestamp with each transport request. Note: thisis ignored if the browser is IE or Android, in which case requestsare always stamped **/ @:optional var timestampRequests : Bool; /** A list of transports to try (in order). Engine.io always attempts toconnect directly with the first one, provided the feature detection testfor it passes. **/ @:optional var transports : Array<String>; /** The port the policy server listens on **/ @:optional var policyPost : Float; /** If true and if the previous websocket connection to the server succeeded,the connection attempt will bypass the normal upgrade process and willinitially try websocket. A connection attempt following a transport errorwill use the normal upgrade process. It is recommended you turn this ononly when using SSL/TLS connections, or if you know that your network doesnot block websockets. **/ @:optional var rememberUpgrade : Bool; /** Are we only interested in transports that support binary? **/ @:optional var onlyBinaryUpgrades : Bool; /** Timeout for xhr-polling requests in milliseconds (0) (only for polling transport) **/ @:optional var requestTimeout : Float; /** Transport options for Node.js client (headers etc) **/ @:optional var transportOptions : Dynamic; /** (SSL) Certificate, Private key and CA certificates to use for SSL.Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var pfx : String; /** (SSL) Private key to use for SSL. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var key : String; /** (SSL) A string or passphrase for the private key or pfx. Can beused in Node.js client environment to manually specify certificateinformation. **/ @:optional var passphrase : String; /** (SSL) Public x509 certificate to use. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var cert : String; /** (SSL) An authority certificate or array of authority certificates tocheck the remote host against.. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var ca : ts.AnyOf2<String, Array<String>>; /** (SSL) A string describing the ciphers to use or exclude. Consult the[cipher format list](http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT) fordetails on the format.. Can be used in Node.js client environment tomanually specify certificate information. **/ @:optional var ciphers : String; /** (SSL) If true, the server certificate is verified against the list ofsupplied CAs. An 'error' event is emitted if verification fails.Verification happens at the connection level, before the HTTP requestis sent. Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var rejectUnauthorized : Bool; /** Headers that will be passed for each request to the server (via xhr-polling and via websockets).These values then can be used during handshake or for special proxies. **/ @:optional var extraHeaders : haxe.DynamicAccess<String>; /** Whether to include credentials (cookies, authorization headers, TLSclient certificates, etc.) with cross-origin XHR polling requests **/ @:optional var withCredentials : Bool; /** Whether to automatically close the connection whenever the beforeunload event is received. **/ @:optional var closeOnBeforeunload : Bool; /** Whether to always use the native timeouts. This allows the client toreconnect when the native timeout functions are overridden, such as whenmock clocks are installed. **/ @:optional var useNativeTimers : Bool; /** weather we should unref the reconnect timer when it iscreate automatically **/ @:optional var autoUnref : Bool; /** parameters of the WebSocket permessage-deflate extension (see ws module api docs). Set to false to disable. **/ @:optional var perMessageDeflate : { var threshold : Float; }; /** Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols,so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server tobe able to handle different types of interactions depending on the specified protocol) **/ @:optional var protocols : ts.AnyOf2<String, Array<String>>; /** the authentication payload sent when connecting to the Namespace **/ @:optional var auth : ts.AnyOf2<haxe.DynamicAccess<Dynamic>, (cb:(data:Dynamic) -> Void) -> Void>; }>, ?opts:{ /** Should we force a new Manager for this connection? **/ @:optional var forceNew : Bool; /** Should we multiplex our connection (reuse existing Manager) ? **/ @:optional var multiplex : Bool; /** The path to get our client file from, in the case of the serverserving it **/ @:optional var path : String; /** Should we allow reconnections? **/ @:optional var reconnection : Bool; /** How many reconnection attempts should we try? **/ @:optional var reconnectionAttempts : Float; /** The time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelay : Float; /** The max time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelayMax : Float; /** Used in the exponential backoff jitter when reconnecting **/ @:optional var randomizationFactor : Float; /** The timeout in milliseconds for our connection attempt **/ @:optional var timeout : Float; /** Should we automatically connect? **/ @:optional var autoConnect : Bool; /** the parser to use. Defaults to an instance of the Parser that ships with socket.io. **/ @:optional var parser : Dynamic; /** The host that we're connecting to. Set from the URI passed when connecting **/ @:optional var host : String; /** The hostname for our connection. Set from the URI passed when connecting **/ @:optional var hostname : String; /** If this is a secure connection. Set from the URI passed when connecting **/ @:optional var secure : Bool; /** The port for our connection. Set from the URI passed when connecting **/ @:optional var port : ts.AnyOf2<String, Float>; /** Any query parameters in our uri. Set from the URI passed when connecting **/ @:optional var query : haxe.DynamicAccess<Dynamic>; /** `http.Agent` to use, defaults to `false` (NodeJS only) **/ @:optional var agent : ts.AnyOf2<String, Bool>; /** Whether the client should try to upgrade the transport fromlong-polling to something better. **/ @:optional var upgrade : Bool; /** Forces base 64 encoding for polling transport even when XHR2responseType is available and WebSocket even if the used standardsupports binary. **/ @:optional var forceBase64 : Bool; /** The param name to use as our timestamp key **/ @:optional var timestampParam : String; /** Whether to add the timestamp with each transport request. Note: thisis ignored if the browser is IE or Android, in which case requestsare always stamped **/ @:optional var timestampRequests : Bool; /** A list of transports to try (in order). Engine.io always attempts toconnect directly with the first one, provided the feature detection testfor it passes. **/ @:optional var transports : Array<String>; /** The port the policy server listens on **/ @:optional var policyPost : Float; /** If true and if the previous websocket connection to the server succeeded,the connection attempt will bypass the normal upgrade process and willinitially try websocket. A connection attempt following a transport errorwill use the normal upgrade process. It is recommended you turn this ononly when using SSL/TLS connections, or if you know that your network doesnot block websockets. **/ @:optional var rememberUpgrade : Bool; /** Are we only interested in transports that support binary? **/ @:optional var onlyBinaryUpgrades : Bool; /** Timeout for xhr-polling requests in milliseconds (0) (only for polling transport) **/ @:optional var requestTimeout : Float; /** Transport options for Node.js client (headers etc) **/ @:optional var transportOptions : Dynamic; /** (SSL) Certificate, Private key and CA certificates to use for SSL.Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var pfx : String; /** (SSL) Private key to use for SSL. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var key : String; /** (SSL) A string or passphrase for the private key or pfx. Can beused in Node.js client environment to manually specify certificateinformation. **/ @:optional var passphrase : String; /** (SSL) Public x509 certificate to use. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var cert : String; /** (SSL) An authority certificate or array of authority certificates tocheck the remote host against.. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var ca : ts.AnyOf2<String, Array<String>>; /** (SSL) A string describing the ciphers to use or exclude. Consult the[cipher format list](http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT) fordetails on the format.. Can be used in Node.js client environment tomanually specify certificate information. **/ @:optional var ciphers : String; /** (SSL) If true, the server certificate is verified against the list ofsupplied CAs. An 'error' event is emitted if verification fails.Verification happens at the connection level, before the HTTP requestis sent. Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var rejectUnauthorized : Bool; /** Headers that will be passed for each request to the server (via xhr-polling and via websockets).These values then can be used during handshake or for special proxies. **/ @:optional var extraHeaders : haxe.DynamicAccess<String>; /** Whether to include credentials (cookies, authorization headers, TLSclient certificates, etc.) with cross-origin XHR polling requests **/ @:optional var withCredentials : Bool; /** Whether to automatically close the connection whenever the beforeunload event is received. **/ @:optional var closeOnBeforeunload : Bool; /** Whether to always use the native timeouts. This allows the client toreconnect when the native timeout functions are overridden, such as whenmock clocks are installed. **/ @:optional var useNativeTimers : Bool; /** weather we should unref the reconnect timer when it iscreate automatically **/ @:optional var autoUnref : Bool; /** parameters of the WebSocket permessage-deflate extension (see ws module api docs). Set to false to disable. **/ @:optional var perMessageDeflate : { var threshold : Float; }; /** Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols,so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server tobe able to handle different types of interactions depending on the specified protocol) **/ @:optional var protocols : ts.AnyOf2<String, Array<String>>; /** the authentication payload sent when connecting to the Namespace **/ @:optional var auth : ts.AnyOf2<haxe.DynamicAccess<Dynamic>, (cb:(data:Dynamic) -> Void) -> Void>; }):socket_io_client.Socket<socket_io.component_emitter.DefaultEventsMap, socket_io.component_emitter.DefaultEventsMap> { })
	static function io(?opts:{ /** Should we force a new Manager for this connection? **/ @:optional var forceNew : Bool; /** Should we multiplex our connection (reuse existing Manager) ? **/ @:optional var multiplex : Bool; /** The path to get our client file from, in the case of the serverserving it **/ @:optional var path : String; /** Should we allow reconnections? **/ @:optional var reconnection : Bool; /** How many reconnection attempts should we try? **/ @:optional var reconnectionAttempts : Float; /** The time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelay : Float; /** The max time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelayMax : Float; /** Used in the exponential backoff jitter when reconnecting **/ @:optional var randomizationFactor : Float; /** The timeout in milliseconds for our connection attempt **/ @:optional var timeout : Float; /** Should we automatically connect? **/ @:optional var autoConnect : Bool; /** the parser to use. Defaults to an instance of the Parser that ships with socket.io. **/ @:optional var parser : Dynamic; /** The host that we're connecting to. Set from the URI passed when connecting **/ @:optional var host : String; /** The hostname for our connection. Set from the URI passed when connecting **/ @:optional var hostname : String; /** If this is a secure connection. Set from the URI passed when connecting **/ @:optional var secure : Bool; /** The port for our connection. Set from the URI passed when connecting **/ @:optional var port : ts.AnyOf2<String, Float>; /** Any query parameters in our uri. Set from the URI passed when connecting **/ @:optional var query : haxe.DynamicAccess<Dynamic>; /** `http.Agent` to use, defaults to `false` (NodeJS only) **/ @:optional var agent : ts.AnyOf2<String, Bool>; /** Whether the client should try to upgrade the transport fromlong-polling to something better. **/ @:optional var upgrade : Bool; /** Forces base 64 encoding for polling transport even when XHR2responseType is available and WebSocket even if the used standardsupports binary. **/ @:optional var forceBase64 : Bool; /** The param name to use as our timestamp key **/ @:optional var timestampParam : String; /** Whether to add the timestamp with each transport request. Note: thisis ignored if the browser is IE or Android, in which case requestsare always stamped **/ @:optional var timestampRequests : Bool; /** A list of transports to try (in order). Engine.io always attempts toconnect directly with the first one, provided the feature detection testfor it passes. **/ @:optional var transports : Array<String>; /** The port the policy server listens on **/ @:optional var policyPost : Float; /** If true and if the previous websocket connection to the server succeeded,the connection attempt will bypass the normal upgrade process and willinitially try websocket. A connection attempt following a transport errorwill use the normal upgrade process. It is recommended you turn this ononly when using SSL/TLS connections, or if you know that your network doesnot block websockets. **/ @:optional var rememberUpgrade : Bool; /** Are we only interested in transports that support binary? **/ @:optional var onlyBinaryUpgrades : Bool; /** Timeout for xhr-polling requests in milliseconds (0) (only for polling transport) **/ @:optional var requestTimeout : Float; /** Transport options for Node.js client (headers etc) **/ @:optional var transportOptions : Dynamic; /** (SSL) Certificate, Private key and CA certificates to use for SSL.Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var pfx : String; /** (SSL) Private key to use for SSL. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var key : String; /** (SSL) A string or passphrase for the private key or pfx. Can beused in Node.js client environment to manually specify certificateinformation. **/ @:optional var passphrase : String; /** (SSL) Public x509 certificate to use. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var cert : String; /** (SSL) An authority certificate or array of authority certificates tocheck the remote host against.. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var ca : ts.AnyOf2<String, Array<String>>; /** (SSL) A string describing the ciphers to use or exclude. Consult the[cipher format list](http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT) fordetails on the format.. Can be used in Node.js client environment tomanually specify certificate information. **/ @:optional var ciphers : String; /** (SSL) If true, the server certificate is verified against the list ofsupplied CAs. An 'error' event is emitted if verification fails.Verification happens at the connection level, before the HTTP requestis sent. Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var rejectUnauthorized : Bool; /** Headers that will be passed for each request to the server (via xhr-polling and via websockets).These values then can be used during handshake or for special proxies. **/ @:optional var extraHeaders : haxe.DynamicAccess<String>; /** Whether to include credentials (cookies, authorization headers, TLSclient certificates, etc.) with cross-origin XHR polling requests **/ @:optional var withCredentials : Bool; /** Whether to automatically close the connection whenever the beforeunload event is received. **/ @:optional var closeOnBeforeunload : Bool; /** Whether to always use the native timeouts. This allows the client toreconnect when the native timeout functions are overridden, such as whenmock clocks are installed. **/ @:optional var useNativeTimers : Bool; /** weather we should unref the reconnect timer when it iscreate automatically **/ @:optional var autoUnref : Bool; /** parameters of the WebSocket permessage-deflate extension (see ws module api docs). Set to false to disable. **/ @:optional var perMessageDeflate : { var threshold : Float; }; /** Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols,so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server tobe able to handle different types of interactions depending on the specified protocol) **/ @:optional var protocols : ts.AnyOf2<String, Array<String>>; /** the authentication payload sent when connecting to the Namespace **/ @:optional var auth : ts.AnyOf2<haxe.DynamicAccess<Dynamic>, (cb:(data:Dynamic) -> Void) -> Void>; }):socket_io_client.Socket<socket_io.component_emitter.DefaultEventsMap, socket_io.component_emitter.DefaultEventsMap>;
	/**
		Looks up an existing `Manager` for multiplexing.
		If the user summons:
		
		   `io('http://localhost/a');`
		   `io('http://localhost/b');`
		
		We reuse the existing instance based on same scheme/port/host,
		and we initialize sockets for each namespace.
	**/
	@:overload(function(uri:String, ?opts:{ /** Should we force a new Manager for this connection? **/ @:optional var forceNew : Bool; /** Should we multiplex our connection (reuse existing Manager) ? **/ @:optional var multiplex : Bool; /** The path to get our client file from, in the case of the serverserving it **/ @:optional var path : String; /** Should we allow reconnections? **/ @:optional var reconnection : Bool; /** How many reconnection attempts should we try? **/ @:optional var reconnectionAttempts : Float; /** The time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelay : Float; /** The max time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelayMax : Float; /** Used in the exponential backoff jitter when reconnecting **/ @:optional var randomizationFactor : Float; /** The timeout in milliseconds for our connection attempt **/ @:optional var timeout : Float; /** Should we automatically connect? **/ @:optional var autoConnect : Bool; /** the parser to use. Defaults to an instance of the Parser that ships with socket.io. **/ @:optional var parser : Dynamic; /** The host that we're connecting to. Set from the URI passed when connecting **/ @:optional var host : String; /** The hostname for our connection. Set from the URI passed when connecting **/ @:optional var hostname : String; /** If this is a secure connection. Set from the URI passed when connecting **/ @:optional var secure : Bool; /** The port for our connection. Set from the URI passed when connecting **/ @:optional var port : ts.AnyOf2<String, Float>; /** Any query parameters in our uri. Set from the URI passed when connecting **/ @:optional var query : haxe.DynamicAccess<Dynamic>; /** `http.Agent` to use, defaults to `false` (NodeJS only) **/ @:optional var agent : ts.AnyOf2<String, Bool>; /** Whether the client should try to upgrade the transport fromlong-polling to something better. **/ @:optional var upgrade : Bool; /** Forces base 64 encoding for polling transport even when XHR2responseType is available and WebSocket even if the used standardsupports binary. **/ @:optional var forceBase64 : Bool; /** The param name to use as our timestamp key **/ @:optional var timestampParam : String; /** Whether to add the timestamp with each transport request. Note: thisis ignored if the browser is IE or Android, in which case requestsare always stamped **/ @:optional var timestampRequests : Bool; /** A list of transports to try (in order). Engine.io always attempts toconnect directly with the first one, provided the feature detection testfor it passes. **/ @:optional var transports : Array<String>; /** The port the policy server listens on **/ @:optional var policyPost : Float; /** If true and if the previous websocket connection to the server succeeded,the connection attempt will bypass the normal upgrade process and willinitially try websocket. A connection attempt following a transport errorwill use the normal upgrade process. It is recommended you turn this ononly when using SSL/TLS connections, or if you know that your network doesnot block websockets. **/ @:optional var rememberUpgrade : Bool; /** Are we only interested in transports that support binary? **/ @:optional var onlyBinaryUpgrades : Bool; /** Timeout for xhr-polling requests in milliseconds (0) (only for polling transport) **/ @:optional var requestTimeout : Float; /** Transport options for Node.js client (headers etc) **/ @:optional var transportOptions : Dynamic; /** (SSL) Certificate, Private key and CA certificates to use for SSL.Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var pfx : String; /** (SSL) Private key to use for SSL. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var key : String; /** (SSL) A string or passphrase for the private key or pfx. Can beused in Node.js client environment to manually specify certificateinformation. **/ @:optional var passphrase : String; /** (SSL) Public x509 certificate to use. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var cert : String; /** (SSL) An authority certificate or array of authority certificates tocheck the remote host against.. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var ca : ts.AnyOf2<String, Array<String>>; /** (SSL) A string describing the ciphers to use or exclude. Consult the[cipher format list](http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT) fordetails on the format.. Can be used in Node.js client environment tomanually specify certificate information. **/ @:optional var ciphers : String; /** (SSL) If true, the server certificate is verified against the list ofsupplied CAs. An 'error' event is emitted if verification fails.Verification happens at the connection level, before the HTTP requestis sent. Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var rejectUnauthorized : Bool; /** Headers that will be passed for each request to the server (via xhr-polling and via websockets).These values then can be used during handshake or for special proxies. **/ @:optional var extraHeaders : haxe.DynamicAccess<String>; /** Whether to include credentials (cookies, authorization headers, TLSclient certificates, etc.) with cross-origin XHR polling requests **/ @:optional var withCredentials : Bool; /** Whether to automatically close the connection whenever the beforeunload event is received. **/ @:optional var closeOnBeforeunload : Bool; /** Whether to always use the native timeouts. This allows the client toreconnect when the native timeout functions are overridden, such as whenmock clocks are installed. **/ @:optional var useNativeTimers : Bool; /** weather we should unref the reconnect timer when it iscreate automatically **/ @:optional var autoUnref : Bool; /** parameters of the WebSocket permessage-deflate extension (see ws module api docs). Set to false to disable. **/ @:optional var perMessageDeflate : { var threshold : Float; }; /** Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols,so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server tobe able to handle different types of interactions depending on the specified protocol) **/ @:optional var protocols : ts.AnyOf2<String, Array<String>>; /** the authentication payload sent when connecting to the Namespace **/ @:optional var auth : ts.AnyOf2<haxe.DynamicAccess<Dynamic>, (cb:(data:Dynamic) -> Void) -> Void>; }):socket_io_client.Socket<socket_io.component_emitter.DefaultEventsMap, socket_io.component_emitter.DefaultEventsMap> { })
	@:overload(function(uri:ts.AnyOf2<String, { /** Should we force a new Manager for this connection? **/ @:optional var forceNew : Bool; /** Should we multiplex our connection (reuse existing Manager) ? **/ @:optional var multiplex : Bool; /** The path to get our client file from, in the case of the serverserving it **/ @:optional var path : String; /** Should we allow reconnections? **/ @:optional var reconnection : Bool; /** How many reconnection attempts should we try? **/ @:optional var reconnectionAttempts : Float; /** The time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelay : Float; /** The max time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelayMax : Float; /** Used in the exponential backoff jitter when reconnecting **/ @:optional var randomizationFactor : Float; /** The timeout in milliseconds for our connection attempt **/ @:optional var timeout : Float; /** Should we automatically connect? **/ @:optional var autoConnect : Bool; /** the parser to use. Defaults to an instance of the Parser that ships with socket.io. **/ @:optional var parser : Dynamic; /** The host that we're connecting to. Set from the URI passed when connecting **/ @:optional var host : String; /** The hostname for our connection. Set from the URI passed when connecting **/ @:optional var hostname : String; /** If this is a secure connection. Set from the URI passed when connecting **/ @:optional var secure : Bool; /** The port for our connection. Set from the URI passed when connecting **/ @:optional var port : ts.AnyOf2<String, Float>; /** Any query parameters in our uri. Set from the URI passed when connecting **/ @:optional var query : haxe.DynamicAccess<Dynamic>; /** `http.Agent` to use, defaults to `false` (NodeJS only) **/ @:optional var agent : ts.AnyOf2<String, Bool>; /** Whether the client should try to upgrade the transport fromlong-polling to something better. **/ @:optional var upgrade : Bool; /** Forces base 64 encoding for polling transport even when XHR2responseType is available and WebSocket even if the used standardsupports binary. **/ @:optional var forceBase64 : Bool; /** The param name to use as our timestamp key **/ @:optional var timestampParam : String; /** Whether to add the timestamp with each transport request. Note: thisis ignored if the browser is IE or Android, in which case requestsare always stamped **/ @:optional var timestampRequests : Bool; /** A list of transports to try (in order). Engine.io always attempts toconnect directly with the first one, provided the feature detection testfor it passes. **/ @:optional var transports : Array<String>; /** The port the policy server listens on **/ @:optional var policyPost : Float; /** If true and if the previous websocket connection to the server succeeded,the connection attempt will bypass the normal upgrade process and willinitially try websocket. A connection attempt following a transport errorwill use the normal upgrade process. It is recommended you turn this ononly when using SSL/TLS connections, or if you know that your network doesnot block websockets. **/ @:optional var rememberUpgrade : Bool; /** Are we only interested in transports that support binary? **/ @:optional var onlyBinaryUpgrades : Bool; /** Timeout for xhr-polling requests in milliseconds (0) (only for polling transport) **/ @:optional var requestTimeout : Float; /** Transport options for Node.js client (headers etc) **/ @:optional var transportOptions : Dynamic; /** (SSL) Certificate, Private key and CA certificates to use for SSL.Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var pfx : String; /** (SSL) Private key to use for SSL. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var key : String; /** (SSL) A string or passphrase for the private key or pfx. Can beused in Node.js client environment to manually specify certificateinformation. **/ @:optional var passphrase : String; /** (SSL) Public x509 certificate to use. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var cert : String; /** (SSL) An authority certificate or array of authority certificates tocheck the remote host against.. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var ca : ts.AnyOf2<String, Array<String>>; /** (SSL) A string describing the ciphers to use or exclude. Consult the[cipher format list](http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT) fordetails on the format.. Can be used in Node.js client environment tomanually specify certificate information. **/ @:optional var ciphers : String; /** (SSL) If true, the server certificate is verified against the list ofsupplied CAs. An 'error' event is emitted if verification fails.Verification happens at the connection level, before the HTTP requestis sent. Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var rejectUnauthorized : Bool; /** Headers that will be passed for each request to the server (via xhr-polling and via websockets).These values then can be used during handshake or for special proxies. **/ @:optional var extraHeaders : haxe.DynamicAccess<String>; /** Whether to include credentials (cookies, authorization headers, TLSclient certificates, etc.) with cross-origin XHR polling requests **/ @:optional var withCredentials : Bool; /** Whether to automatically close the connection whenever the beforeunload event is received. **/ @:optional var closeOnBeforeunload : Bool; /** Whether to always use the native timeouts. This allows the client toreconnect when the native timeout functions are overridden, such as whenmock clocks are installed. **/ @:optional var useNativeTimers : Bool; /** weather we should unref the reconnect timer when it iscreate automatically **/ @:optional var autoUnref : Bool; /** parameters of the WebSocket permessage-deflate extension (see ws module api docs). Set to false to disable. **/ @:optional var perMessageDeflate : { var threshold : Float; }; /** Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols,so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server tobe able to handle different types of interactions depending on the specified protocol) **/ @:optional var protocols : ts.AnyOf2<String, Array<String>>; /** the authentication payload sent when connecting to the Namespace **/ @:optional var auth : ts.AnyOf2<haxe.DynamicAccess<Dynamic>, (cb:(data:Dynamic) -> Void) -> Void>; }>, ?opts:{ /** Should we force a new Manager for this connection? **/ @:optional var forceNew : Bool; /** Should we multiplex our connection (reuse existing Manager) ? **/ @:optional var multiplex : Bool; /** The path to get our client file from, in the case of the serverserving it **/ @:optional var path : String; /** Should we allow reconnections? **/ @:optional var reconnection : Bool; /** How many reconnection attempts should we try? **/ @:optional var reconnectionAttempts : Float; /** The time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelay : Float; /** The max time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelayMax : Float; /** Used in the exponential backoff jitter when reconnecting **/ @:optional var randomizationFactor : Float; /** The timeout in milliseconds for our connection attempt **/ @:optional var timeout : Float; /** Should we automatically connect? **/ @:optional var autoConnect : Bool; /** the parser to use. Defaults to an instance of the Parser that ships with socket.io. **/ @:optional var parser : Dynamic; /** The host that we're connecting to. Set from the URI passed when connecting **/ @:optional var host : String; /** The hostname for our connection. Set from the URI passed when connecting **/ @:optional var hostname : String; /** If this is a secure connection. Set from the URI passed when connecting **/ @:optional var secure : Bool; /** The port for our connection. Set from the URI passed when connecting **/ @:optional var port : ts.AnyOf2<String, Float>; /** Any query parameters in our uri. Set from the URI passed when connecting **/ @:optional var query : haxe.DynamicAccess<Dynamic>; /** `http.Agent` to use, defaults to `false` (NodeJS only) **/ @:optional var agent : ts.AnyOf2<String, Bool>; /** Whether the client should try to upgrade the transport fromlong-polling to something better. **/ @:optional var upgrade : Bool; /** Forces base 64 encoding for polling transport even when XHR2responseType is available and WebSocket even if the used standardsupports binary. **/ @:optional var forceBase64 : Bool; /** The param name to use as our timestamp key **/ @:optional var timestampParam : String; /** Whether to add the timestamp with each transport request. Note: thisis ignored if the browser is IE or Android, in which case requestsare always stamped **/ @:optional var timestampRequests : Bool; /** A list of transports to try (in order). Engine.io always attempts toconnect directly with the first one, provided the feature detection testfor it passes. **/ @:optional var transports : Array<String>; /** The port the policy server listens on **/ @:optional var policyPost : Float; /** If true and if the previous websocket connection to the server succeeded,the connection attempt will bypass the normal upgrade process and willinitially try websocket. A connection attempt following a transport errorwill use the normal upgrade process. It is recommended you turn this ononly when using SSL/TLS connections, or if you know that your network doesnot block websockets. **/ @:optional var rememberUpgrade : Bool; /** Are we only interested in transports that support binary? **/ @:optional var onlyBinaryUpgrades : Bool; /** Timeout for xhr-polling requests in milliseconds (0) (only for polling transport) **/ @:optional var requestTimeout : Float; /** Transport options for Node.js client (headers etc) **/ @:optional var transportOptions : Dynamic; /** (SSL) Certificate, Private key and CA certificates to use for SSL.Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var pfx : String; /** (SSL) Private key to use for SSL. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var key : String; /** (SSL) A string or passphrase for the private key or pfx. Can beused in Node.js client environment to manually specify certificateinformation. **/ @:optional var passphrase : String; /** (SSL) Public x509 certificate to use. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var cert : String; /** (SSL) An authority certificate or array of authority certificates tocheck the remote host against.. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var ca : ts.AnyOf2<String, Array<String>>; /** (SSL) A string describing the ciphers to use or exclude. Consult the[cipher format list](http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT) fordetails on the format.. Can be used in Node.js client environment tomanually specify certificate information. **/ @:optional var ciphers : String; /** (SSL) If true, the server certificate is verified against the list ofsupplied CAs. An 'error' event is emitted if verification fails.Verification happens at the connection level, before the HTTP requestis sent. Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var rejectUnauthorized : Bool; /** Headers that will be passed for each request to the server (via xhr-polling and via websockets).These values then can be used during handshake or for special proxies. **/ @:optional var extraHeaders : haxe.DynamicAccess<String>; /** Whether to include credentials (cookies, authorization headers, TLSclient certificates, etc.) with cross-origin XHR polling requests **/ @:optional var withCredentials : Bool; /** Whether to automatically close the connection whenever the beforeunload event is received. **/ @:optional var closeOnBeforeunload : Bool; /** Whether to always use the native timeouts. This allows the client toreconnect when the native timeout functions are overridden, such as whenmock clocks are installed. **/ @:optional var useNativeTimers : Bool; /** weather we should unref the reconnect timer when it iscreate automatically **/ @:optional var autoUnref : Bool; /** parameters of the WebSocket permessage-deflate extension (see ws module api docs). Set to false to disable. **/ @:optional var perMessageDeflate : { var threshold : Float; }; /** Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols,so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server tobe able to handle different types of interactions depending on the specified protocol) **/ @:optional var protocols : ts.AnyOf2<String, Array<String>>; /** the authentication payload sent when connecting to the Namespace **/ @:optional var auth : ts.AnyOf2<haxe.DynamicAccess<Dynamic>, (cb:(data:Dynamic) -> Void) -> Void>; }):socket_io_client.Socket<socket_io.component_emitter.DefaultEventsMap, socket_io.component_emitter.DefaultEventsMap> { })
	static function connect(?opts:{ /** Should we force a new Manager for this connection? **/ @:optional var forceNew : Bool; /** Should we multiplex our connection (reuse existing Manager) ? **/ @:optional var multiplex : Bool; /** The path to get our client file from, in the case of the serverserving it **/ @:optional var path : String; /** Should we allow reconnections? **/ @:optional var reconnection : Bool; /** How many reconnection attempts should we try? **/ @:optional var reconnectionAttempts : Float; /** The time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelay : Float; /** The max time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelayMax : Float; /** Used in the exponential backoff jitter when reconnecting **/ @:optional var randomizationFactor : Float; /** The timeout in milliseconds for our connection attempt **/ @:optional var timeout : Float; /** Should we automatically connect? **/ @:optional var autoConnect : Bool; /** the parser to use. Defaults to an instance of the Parser that ships with socket.io. **/ @:optional var parser : Dynamic; /** The host that we're connecting to. Set from the URI passed when connecting **/ @:optional var host : String; /** The hostname for our connection. Set from the URI passed when connecting **/ @:optional var hostname : String; /** If this is a secure connection. Set from the URI passed when connecting **/ @:optional var secure : Bool; /** The port for our connection. Set from the URI passed when connecting **/ @:optional var port : ts.AnyOf2<String, Float>; /** Any query parameters in our uri. Set from the URI passed when connecting **/ @:optional var query : haxe.DynamicAccess<Dynamic>; /** `http.Agent` to use, defaults to `false` (NodeJS only) **/ @:optional var agent : ts.AnyOf2<String, Bool>; /** Whether the client should try to upgrade the transport fromlong-polling to something better. **/ @:optional var upgrade : Bool; /** Forces base 64 encoding for polling transport even when XHR2responseType is available and WebSocket even if the used standardsupports binary. **/ @:optional var forceBase64 : Bool; /** The param name to use as our timestamp key **/ @:optional var timestampParam : String; /** Whether to add the timestamp with each transport request. Note: thisis ignored if the browser is IE or Android, in which case requestsare always stamped **/ @:optional var timestampRequests : Bool; /** A list of transports to try (in order). Engine.io always attempts toconnect directly with the first one, provided the feature detection testfor it passes. **/ @:optional var transports : Array<String>; /** The port the policy server listens on **/ @:optional var policyPost : Float; /** If true and if the previous websocket connection to the server succeeded,the connection attempt will bypass the normal upgrade process and willinitially try websocket. A connection attempt following a transport errorwill use the normal upgrade process. It is recommended you turn this ononly when using SSL/TLS connections, or if you know that your network doesnot block websockets. **/ @:optional var rememberUpgrade : Bool; /** Are we only interested in transports that support binary? **/ @:optional var onlyBinaryUpgrades : Bool; /** Timeout for xhr-polling requests in milliseconds (0) (only for polling transport) **/ @:optional var requestTimeout : Float; /** Transport options for Node.js client (headers etc) **/ @:optional var transportOptions : Dynamic; /** (SSL) Certificate, Private key and CA certificates to use for SSL.Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var pfx : String; /** (SSL) Private key to use for SSL. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var key : String; /** (SSL) A string or passphrase for the private key or pfx. Can beused in Node.js client environment to manually specify certificateinformation. **/ @:optional var passphrase : String; /** (SSL) Public x509 certificate to use. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var cert : String; /** (SSL) An authority certificate or array of authority certificates tocheck the remote host against.. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var ca : ts.AnyOf2<String, Array<String>>; /** (SSL) A string describing the ciphers to use or exclude. Consult the[cipher format list](http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT) fordetails on the format.. Can be used in Node.js client environment tomanually specify certificate information. **/ @:optional var ciphers : String; /** (SSL) If true, the server certificate is verified against the list ofsupplied CAs. An 'error' event is emitted if verification fails.Verification happens at the connection level, before the HTTP requestis sent. Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var rejectUnauthorized : Bool; /** Headers that will be passed for each request to the server (via xhr-polling and via websockets).These values then can be used during handshake or for special proxies. **/ @:optional var extraHeaders : haxe.DynamicAccess<String>; /** Whether to include credentials (cookies, authorization headers, TLSclient certificates, etc.) with cross-origin XHR polling requests **/ @:optional var withCredentials : Bool; /** Whether to automatically close the connection whenever the beforeunload event is received. **/ @:optional var closeOnBeforeunload : Bool; /** Whether to always use the native timeouts. This allows the client toreconnect when the native timeout functions are overridden, such as whenmock clocks are installed. **/ @:optional var useNativeTimers : Bool; /** weather we should unref the reconnect timer when it iscreate automatically **/ @:optional var autoUnref : Bool; /** parameters of the WebSocket permessage-deflate extension (see ws module api docs). Set to false to disable. **/ @:optional var perMessageDeflate : { var threshold : Float; }; /** Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols,so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server tobe able to handle different types of interactions depending on the specified protocol) **/ @:optional var protocols : ts.AnyOf2<String, Array<String>>; /** the authentication payload sent when connecting to the Namespace **/ @:optional var auth : ts.AnyOf2<haxe.DynamicAccess<Dynamic>, (cb:(data:Dynamic) -> Void) -> Void>; }):socket_io_client.Socket<socket_io.component_emitter.DefaultEventsMap, socket_io.component_emitter.DefaultEventsMap>;
	/**
		Looks up an existing `Manager` for multiplexing.
		If the user summons:
		
		   `io('http://localhost/a');`
		   `io('http://localhost/b');`
		
		We reuse the existing instance based on same scheme/port/host,
		and we initialize sockets for each namespace.
	**/
	@:native("default")
	@:overload(function(uri:String, ?opts:{ /** Should we force a new Manager for this connection? **/ @:optional var forceNew : Bool; /** Should we multiplex our connection (reuse existing Manager) ? **/ @:optional var multiplex : Bool; /** The path to get our client file from, in the case of the serverserving it **/ @:optional var path : String; /** Should we allow reconnections? **/ @:optional var reconnection : Bool; /** How many reconnection attempts should we try? **/ @:optional var reconnectionAttempts : Float; /** The time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelay : Float; /** The max time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelayMax : Float; /** Used in the exponential backoff jitter when reconnecting **/ @:optional var randomizationFactor : Float; /** The timeout in milliseconds for our connection attempt **/ @:optional var timeout : Float; /** Should we automatically connect? **/ @:optional var autoConnect : Bool; /** the parser to use. Defaults to an instance of the Parser that ships with socket.io. **/ @:optional var parser : Dynamic; /** The host that we're connecting to. Set from the URI passed when connecting **/ @:optional var host : String; /** The hostname for our connection. Set from the URI passed when connecting **/ @:optional var hostname : String; /** If this is a secure connection. Set from the URI passed when connecting **/ @:optional var secure : Bool; /** The port for our connection. Set from the URI passed when connecting **/ @:optional var port : ts.AnyOf2<String, Float>; /** Any query parameters in our uri. Set from the URI passed when connecting **/ @:optional var query : haxe.DynamicAccess<Dynamic>; /** `http.Agent` to use, defaults to `false` (NodeJS only) **/ @:optional var agent : ts.AnyOf2<String, Bool>; /** Whether the client should try to upgrade the transport fromlong-polling to something better. **/ @:optional var upgrade : Bool; /** Forces base 64 encoding for polling transport even when XHR2responseType is available and WebSocket even if the used standardsupports binary. **/ @:optional var forceBase64 : Bool; /** The param name to use as our timestamp key **/ @:optional var timestampParam : String; /** Whether to add the timestamp with each transport request. Note: thisis ignored if the browser is IE or Android, in which case requestsare always stamped **/ @:optional var timestampRequests : Bool; /** A list of transports to try (in order). Engine.io always attempts toconnect directly with the first one, provided the feature detection testfor it passes. **/ @:optional var transports : Array<String>; /** The port the policy server listens on **/ @:optional var policyPost : Float; /** If true and if the previous websocket connection to the server succeeded,the connection attempt will bypass the normal upgrade process and willinitially try websocket. A connection attempt following a transport errorwill use the normal upgrade process. It is recommended you turn this ononly when using SSL/TLS connections, or if you know that your network doesnot block websockets. **/ @:optional var rememberUpgrade : Bool; /** Are we only interested in transports that support binary? **/ @:optional var onlyBinaryUpgrades : Bool; /** Timeout for xhr-polling requests in milliseconds (0) (only for polling transport) **/ @:optional var requestTimeout : Float; /** Transport options for Node.js client (headers etc) **/ @:optional var transportOptions : Dynamic; /** (SSL) Certificate, Private key and CA certificates to use for SSL.Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var pfx : String; /** (SSL) Private key to use for SSL. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var key : String; /** (SSL) A string or passphrase for the private key or pfx. Can beused in Node.js client environment to manually specify certificateinformation. **/ @:optional var passphrase : String; /** (SSL) Public x509 certificate to use. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var cert : String; /** (SSL) An authority certificate or array of authority certificates tocheck the remote host against.. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var ca : ts.AnyOf2<String, Array<String>>; /** (SSL) A string describing the ciphers to use or exclude. Consult the[cipher format list](http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT) fordetails on the format.. Can be used in Node.js client environment tomanually specify certificate information. **/ @:optional var ciphers : String; /** (SSL) If true, the server certificate is verified against the list ofsupplied CAs. An 'error' event is emitted if verification fails.Verification happens at the connection level, before the HTTP requestis sent. Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var rejectUnauthorized : Bool; /** Headers that will be passed for each request to the server (via xhr-polling and via websockets).These values then can be used during handshake or for special proxies. **/ @:optional var extraHeaders : haxe.DynamicAccess<String>; /** Whether to include credentials (cookies, authorization headers, TLSclient certificates, etc.) with cross-origin XHR polling requests **/ @:optional var withCredentials : Bool; /** Whether to automatically close the connection whenever the beforeunload event is received. **/ @:optional var closeOnBeforeunload : Bool; /** Whether to always use the native timeouts. This allows the client toreconnect when the native timeout functions are overridden, such as whenmock clocks are installed. **/ @:optional var useNativeTimers : Bool; /** weather we should unref the reconnect timer when it iscreate automatically **/ @:optional var autoUnref : Bool; /** parameters of the WebSocket permessage-deflate extension (see ws module api docs). Set to false to disable. **/ @:optional var perMessageDeflate : { var threshold : Float; }; /** Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols,so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server tobe able to handle different types of interactions depending on the specified protocol) **/ @:optional var protocols : ts.AnyOf2<String, Array<String>>; /** the authentication payload sent when connecting to the Namespace **/ @:optional var auth : ts.AnyOf2<haxe.DynamicAccess<Dynamic>, (cb:(data:Dynamic) -> Void) -> Void>; }):socket_io_client.Socket<socket_io.component_emitter.DefaultEventsMap, socket_io.component_emitter.DefaultEventsMap> { })
	@:overload(function(uri:ts.AnyOf2<String, { /** Should we force a new Manager for this connection? **/ @:optional var forceNew : Bool; /** Should we multiplex our connection (reuse existing Manager) ? **/ @:optional var multiplex : Bool; /** The path to get our client file from, in the case of the serverserving it **/ @:optional var path : String; /** Should we allow reconnections? **/ @:optional var reconnection : Bool; /** How many reconnection attempts should we try? **/ @:optional var reconnectionAttempts : Float; /** The time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelay : Float; /** The max time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelayMax : Float; /** Used in the exponential backoff jitter when reconnecting **/ @:optional var randomizationFactor : Float; /** The timeout in milliseconds for our connection attempt **/ @:optional var timeout : Float; /** Should we automatically connect? **/ @:optional var autoConnect : Bool; /** the parser to use. Defaults to an instance of the Parser that ships with socket.io. **/ @:optional var parser : Dynamic; /** The host that we're connecting to. Set from the URI passed when connecting **/ @:optional var host : String; /** The hostname for our connection. Set from the URI passed when connecting **/ @:optional var hostname : String; /** If this is a secure connection. Set from the URI passed when connecting **/ @:optional var secure : Bool; /** The port for our connection. Set from the URI passed when connecting **/ @:optional var port : ts.AnyOf2<String, Float>; /** Any query parameters in our uri. Set from the URI passed when connecting **/ @:optional var query : haxe.DynamicAccess<Dynamic>; /** `http.Agent` to use, defaults to `false` (NodeJS only) **/ @:optional var agent : ts.AnyOf2<String, Bool>; /** Whether the client should try to upgrade the transport fromlong-polling to something better. **/ @:optional var upgrade : Bool; /** Forces base 64 encoding for polling transport even when XHR2responseType is available and WebSocket even if the used standardsupports binary. **/ @:optional var forceBase64 : Bool; /** The param name to use as our timestamp key **/ @:optional var timestampParam : String; /** Whether to add the timestamp with each transport request. Note: thisis ignored if the browser is IE or Android, in which case requestsare always stamped **/ @:optional var timestampRequests : Bool; /** A list of transports to try (in order). Engine.io always attempts toconnect directly with the first one, provided the feature detection testfor it passes. **/ @:optional var transports : Array<String>; /** The port the policy server listens on **/ @:optional var policyPost : Float; /** If true and if the previous websocket connection to the server succeeded,the connection attempt will bypass the normal upgrade process and willinitially try websocket. A connection attempt following a transport errorwill use the normal upgrade process. It is recommended you turn this ononly when using SSL/TLS connections, or if you know that your network doesnot block websockets. **/ @:optional var rememberUpgrade : Bool; /** Are we only interested in transports that support binary? **/ @:optional var onlyBinaryUpgrades : Bool; /** Timeout for xhr-polling requests in milliseconds (0) (only for polling transport) **/ @:optional var requestTimeout : Float; /** Transport options for Node.js client (headers etc) **/ @:optional var transportOptions : Dynamic; /** (SSL) Certificate, Private key and CA certificates to use for SSL.Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var pfx : String; /** (SSL) Private key to use for SSL. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var key : String; /** (SSL) A string or passphrase for the private key or pfx. Can beused in Node.js client environment to manually specify certificateinformation. **/ @:optional var passphrase : String; /** (SSL) Public x509 certificate to use. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var cert : String; /** (SSL) An authority certificate or array of authority certificates tocheck the remote host against.. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var ca : ts.AnyOf2<String, Array<String>>; /** (SSL) A string describing the ciphers to use or exclude. Consult the[cipher format list](http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT) fordetails on the format.. Can be used in Node.js client environment tomanually specify certificate information. **/ @:optional var ciphers : String; /** (SSL) If true, the server certificate is verified against the list ofsupplied CAs. An 'error' event is emitted if verification fails.Verification happens at the connection level, before the HTTP requestis sent. Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var rejectUnauthorized : Bool; /** Headers that will be passed for each request to the server (via xhr-polling and via websockets).These values then can be used during handshake or for special proxies. **/ @:optional var extraHeaders : haxe.DynamicAccess<String>; /** Whether to include credentials (cookies, authorization headers, TLSclient certificates, etc.) with cross-origin XHR polling requests **/ @:optional var withCredentials : Bool; /** Whether to automatically close the connection whenever the beforeunload event is received. **/ @:optional var closeOnBeforeunload : Bool; /** Whether to always use the native timeouts. This allows the client toreconnect when the native timeout functions are overridden, such as whenmock clocks are installed. **/ @:optional var useNativeTimers : Bool; /** weather we should unref the reconnect timer when it iscreate automatically **/ @:optional var autoUnref : Bool; /** parameters of the WebSocket permessage-deflate extension (see ws module api docs). Set to false to disable. **/ @:optional var perMessageDeflate : { var threshold : Float; }; /** Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols,so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server tobe able to handle different types of interactions depending on the specified protocol) **/ @:optional var protocols : ts.AnyOf2<String, Array<String>>; /** the authentication payload sent when connecting to the Namespace **/ @:optional var auth : ts.AnyOf2<haxe.DynamicAccess<Dynamic>, (cb:(data:Dynamic) -> Void) -> Void>; }>, ?opts:{ /** Should we force a new Manager for this connection? **/ @:optional var forceNew : Bool; /** Should we multiplex our connection (reuse existing Manager) ? **/ @:optional var multiplex : Bool; /** The path to get our client file from, in the case of the serverserving it **/ @:optional var path : String; /** Should we allow reconnections? **/ @:optional var reconnection : Bool; /** How many reconnection attempts should we try? **/ @:optional var reconnectionAttempts : Float; /** The time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelay : Float; /** The max time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelayMax : Float; /** Used in the exponential backoff jitter when reconnecting **/ @:optional var randomizationFactor : Float; /** The timeout in milliseconds for our connection attempt **/ @:optional var timeout : Float; /** Should we automatically connect? **/ @:optional var autoConnect : Bool; /** the parser to use. Defaults to an instance of the Parser that ships with socket.io. **/ @:optional var parser : Dynamic; /** The host that we're connecting to. Set from the URI passed when connecting **/ @:optional var host : String; /** The hostname for our connection. Set from the URI passed when connecting **/ @:optional var hostname : String; /** If this is a secure connection. Set from the URI passed when connecting **/ @:optional var secure : Bool; /** The port for our connection. Set from the URI passed when connecting **/ @:optional var port : ts.AnyOf2<String, Float>; /** Any query parameters in our uri. Set from the URI passed when connecting **/ @:optional var query : haxe.DynamicAccess<Dynamic>; /** `http.Agent` to use, defaults to `false` (NodeJS only) **/ @:optional var agent : ts.AnyOf2<String, Bool>; /** Whether the client should try to upgrade the transport fromlong-polling to something better. **/ @:optional var upgrade : Bool; /** Forces base 64 encoding for polling transport even when XHR2responseType is available and WebSocket even if the used standardsupports binary. **/ @:optional var forceBase64 : Bool; /** The param name to use as our timestamp key **/ @:optional var timestampParam : String; /** Whether to add the timestamp with each transport request. Note: thisis ignored if the browser is IE or Android, in which case requestsare always stamped **/ @:optional var timestampRequests : Bool; /** A list of transports to try (in order). Engine.io always attempts toconnect directly with the first one, provided the feature detection testfor it passes. **/ @:optional var transports : Array<String>; /** The port the policy server listens on **/ @:optional var policyPost : Float; /** If true and if the previous websocket connection to the server succeeded,the connection attempt will bypass the normal upgrade process and willinitially try websocket. A connection attempt following a transport errorwill use the normal upgrade process. It is recommended you turn this ononly when using SSL/TLS connections, or if you know that your network doesnot block websockets. **/ @:optional var rememberUpgrade : Bool; /** Are we only interested in transports that support binary? **/ @:optional var onlyBinaryUpgrades : Bool; /** Timeout for xhr-polling requests in milliseconds (0) (only for polling transport) **/ @:optional var requestTimeout : Float; /** Transport options for Node.js client (headers etc) **/ @:optional var transportOptions : Dynamic; /** (SSL) Certificate, Private key and CA certificates to use for SSL.Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var pfx : String; /** (SSL) Private key to use for SSL. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var key : String; /** (SSL) A string or passphrase for the private key or pfx. Can beused in Node.js client environment to manually specify certificateinformation. **/ @:optional var passphrase : String; /** (SSL) Public x509 certificate to use. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var cert : String; /** (SSL) An authority certificate or array of authority certificates tocheck the remote host against.. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var ca : ts.AnyOf2<String, Array<String>>; /** (SSL) A string describing the ciphers to use or exclude. Consult the[cipher format list](http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT) fordetails on the format.. Can be used in Node.js client environment tomanually specify certificate information. **/ @:optional var ciphers : String; /** (SSL) If true, the server certificate is verified against the list ofsupplied CAs. An 'error' event is emitted if verification fails.Verification happens at the connection level, before the HTTP requestis sent. Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var rejectUnauthorized : Bool; /** Headers that will be passed for each request to the server (via xhr-polling and via websockets).These values then can be used during handshake or for special proxies. **/ @:optional var extraHeaders : haxe.DynamicAccess<String>; /** Whether to include credentials (cookies, authorization headers, TLSclient certificates, etc.) with cross-origin XHR polling requests **/ @:optional var withCredentials : Bool; /** Whether to automatically close the connection whenever the beforeunload event is received. **/ @:optional var closeOnBeforeunload : Bool; /** Whether to always use the native timeouts. This allows the client toreconnect when the native timeout functions are overridden, such as whenmock clocks are installed. **/ @:optional var useNativeTimers : Bool; /** weather we should unref the reconnect timer when it iscreate automatically **/ @:optional var autoUnref : Bool; /** parameters of the WebSocket permessage-deflate extension (see ws module api docs). Set to false to disable. **/ @:optional var perMessageDeflate : { var threshold : Float; }; /** Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols,so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server tobe able to handle different types of interactions depending on the specified protocol) **/ @:optional var protocols : ts.AnyOf2<String, Array<String>>; /** the authentication payload sent when connecting to the Namespace **/ @:optional var auth : ts.AnyOf2<haxe.DynamicAccess<Dynamic>, (cb:(data:Dynamic) -> Void) -> Void>; }):socket_io_client.Socket<socket_io.component_emitter.DefaultEventsMap, socket_io.component_emitter.DefaultEventsMap> { })
	static function default_(?opts:{ /** Should we force a new Manager for this connection? **/ @:optional var forceNew : Bool; /** Should we multiplex our connection (reuse existing Manager) ? **/ @:optional var multiplex : Bool; /** The path to get our client file from, in the case of the serverserving it **/ @:optional var path : String; /** Should we allow reconnections? **/ @:optional var reconnection : Bool; /** How many reconnection attempts should we try? **/ @:optional var reconnectionAttempts : Float; /** The time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelay : Float; /** The max time delay in milliseconds between reconnection attempts **/ @:optional var reconnectionDelayMax : Float; /** Used in the exponential backoff jitter when reconnecting **/ @:optional var randomizationFactor : Float; /** The timeout in milliseconds for our connection attempt **/ @:optional var timeout : Float; /** Should we automatically connect? **/ @:optional var autoConnect : Bool; /** the parser to use. Defaults to an instance of the Parser that ships with socket.io. **/ @:optional var parser : Dynamic; /** The host that we're connecting to. Set from the URI passed when connecting **/ @:optional var host : String; /** The hostname for our connection. Set from the URI passed when connecting **/ @:optional var hostname : String; /** If this is a secure connection. Set from the URI passed when connecting **/ @:optional var secure : Bool; /** The port for our connection. Set from the URI passed when connecting **/ @:optional var port : ts.AnyOf2<String, Float>; /** Any query parameters in our uri. Set from the URI passed when connecting **/ @:optional var query : haxe.DynamicAccess<Dynamic>; /** `http.Agent` to use, defaults to `false` (NodeJS only) **/ @:optional var agent : ts.AnyOf2<String, Bool>; /** Whether the client should try to upgrade the transport fromlong-polling to something better. **/ @:optional var upgrade : Bool; /** Forces base 64 encoding for polling transport even when XHR2responseType is available and WebSocket even if the used standardsupports binary. **/ @:optional var forceBase64 : Bool; /** The param name to use as our timestamp key **/ @:optional var timestampParam : String; /** Whether to add the timestamp with each transport request. Note: thisis ignored if the browser is IE or Android, in which case requestsare always stamped **/ @:optional var timestampRequests : Bool; /** A list of transports to try (in order). Engine.io always attempts toconnect directly with the first one, provided the feature detection testfor it passes. **/ @:optional var transports : Array<String>; /** The port the policy server listens on **/ @:optional var policyPost : Float; /** If true and if the previous websocket connection to the server succeeded,the connection attempt will bypass the normal upgrade process and willinitially try websocket. A connection attempt following a transport errorwill use the normal upgrade process. It is recommended you turn this ononly when using SSL/TLS connections, or if you know that your network doesnot block websockets. **/ @:optional var rememberUpgrade : Bool; /** Are we only interested in transports that support binary? **/ @:optional var onlyBinaryUpgrades : Bool; /** Timeout for xhr-polling requests in milliseconds (0) (only for polling transport) **/ @:optional var requestTimeout : Float; /** Transport options for Node.js client (headers etc) **/ @:optional var transportOptions : Dynamic; /** (SSL) Certificate, Private key and CA certificates to use for SSL.Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var pfx : String; /** (SSL) Private key to use for SSL. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var key : String; /** (SSL) A string or passphrase for the private key or pfx. Can beused in Node.js client environment to manually specify certificateinformation. **/ @:optional var passphrase : String; /** (SSL) Public x509 certificate to use. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var cert : String; /** (SSL) An authority certificate or array of authority certificates tocheck the remote host against.. Can be used in Node.js clientenvironment to manually specify certificate information. **/ @:optional var ca : ts.AnyOf2<String, Array<String>>; /** (SSL) A string describing the ciphers to use or exclude. Consult the[cipher format list](http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT) fordetails on the format.. Can be used in Node.js client environment tomanually specify certificate information. **/ @:optional var ciphers : String; /** (SSL) If true, the server certificate is verified against the list ofsupplied CAs. An 'error' event is emitted if verification fails.Verification happens at the connection level, before the HTTP requestis sent. Can be used in Node.js client environment to manually specifycertificate information. **/ @:optional var rejectUnauthorized : Bool; /** Headers that will be passed for each request to the server (via xhr-polling and via websockets).These values then can be used during handshake or for special proxies. **/ @:optional var extraHeaders : haxe.DynamicAccess<String>; /** Whether to include credentials (cookies, authorization headers, TLSclient certificates, etc.) with cross-origin XHR polling requests **/ @:optional var withCredentials : Bool; /** Whether to automatically close the connection whenever the beforeunload event is received. **/ @:optional var closeOnBeforeunload : Bool; /** Whether to always use the native timeouts. This allows the client toreconnect when the native timeout functions are overridden, such as whenmock clocks are installed. **/ @:optional var useNativeTimers : Bool; /** weather we should unref the reconnect timer when it iscreate automatically **/ @:optional var autoUnref : Bool; /** parameters of the WebSocket permessage-deflate extension (see ws module api docs). Set to false to disable. **/ @:optional var perMessageDeflate : { var threshold : Float; }; /** Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols,so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server tobe able to handle different types of interactions depending on the specified protocol) **/ @:optional var protocols : ts.AnyOf2<String, Array<String>>; /** the authentication payload sent when connecting to the Namespace **/ @:optional var auth : ts.AnyOf2<haxe.DynamicAccess<Dynamic>, (cb:(data:Dynamic) -> Void) -> Void>; }):socket_io_client.Socket<socket_io.component_emitter.DefaultEventsMap, socket_io.component_emitter.DefaultEventsMap>;
}